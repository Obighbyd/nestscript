func @@main() {
    VAR %r0;
    FUNC %r0 @@f0;
    PUSH %r0;
    FUNC %r0 @@f1;
    CALL_REG %r0 1 false;
    MOV $RET $RET;
}
func @@f0() {
    VAR @c0;
    ALLOC @c0;
    VAR @c1;
    ALLOC @c1;
    VAR btoa;
    VAR atob;
    VAR %r0;
    VAR %r1;
    VAR %r2;
    VAR %r3;
    FUNC @c1 @@f2;
    FUNC btoa @@f3;
    FUNC atob @@f4;
    MOV @c0 "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    CALL_CTX 'Error' 0 true;
    MOV %r0 $RET;
    MOV %r1 @c1;
    MOV %r2 "prototype";
    SET_KEY %r1 %r2 %r0;
    MOV %r0 "InvalidCharacterError";
    MOV %r3 @c1;
    MOV %r2 "prototype";
    MOV_PROP %r1 %r3 %r2;
    MOV %r2 "name";
    SET_KEY %r1 %r2 %r0;
    NEW_OBJ %r0;
    MOV %r1 btoa;
    SET_KEY %r0 'btoa' %r1;
    MOV %r1 atob;
    SET_KEY %r0 'atob' %r1;
    MOV $RET %r0;
    RET;
}
func @@f1(f) {
    VAR base64;
    VAR global;
    VAR %r0;
    VAR %r1;
    VAR %r2;
    VAR %r3;
    VAR %r4;
    VAR %r5;
    VAR %r6;
    MOV_CTX %r2 "exports";
    TYPE_OF %r2;
    MOV %r3 "object";
    EQ %r2 %r3;
    MOV %r1 %r2;
    JF %r2 _l3_;
    MOV_CTX %r3 "exports";
    MOV %r4 null;
    WNE %r3 %r4;
    LG_AND %r1 %r3;
LABEL _l3_:
    MOV %r0 %r1;
    JF %r1 _l2_;
    MOV_CTX %r4 "exports";
    MOV %r5 "nodeType";
    MOV_PROP %r2 %r4 %r5;
    TYPE_OF %r2;
    MOV %r3 "number";
    NE %r2 %r3;
    LG_AND %r0 %r2;
LABEL _l2_:
    JF %r0 _l0_;
    CALL_REG f 0 false;
    MOV %r1 $RET;
    MOV_CTX %r2 "module";
    MOV %r3 "exports";
    SET_KEY %r2 %r3 %r1;
    JMP _l1_;
LABEL _l0_:
    MOV_CTX %r2 "define";
    TYPE_OF %r2;
    MOV %r3 "function";
    EQ %r2 %r3;
    MOV %r1 %r2;
    JF %r2 _l5_;
    MOV_CTX %r5 "define";
    MOV %r6 "amd";
    MOV_PROP %r3 %r5 %r6;
    MOV %r4 null;
    WNE %r3 %r4;
    LG_AND %r1 %r3;
LABEL _l5_:
    JF %r1 _l4_;
    MOV %r2 f;
    PUSH %r2;
    NEW_ARR %r2;
    PUSH %r2;
    CALL_CTX 'define' 2 false;
    JMP _l1_;
LABEL _l4_:
    CALL_REG f 0 false;
    MOV base64 $RET;
    MOV_CTX %r2 "self";
    TYPE_OF %r2;
    MOV %r3 "undefined";
    NE %r2 %r3;
    JF %r2 _l6_;
    MOV_CTX global "self";
    JMP _l1_;
LABEL _l6_:
    MOV_CTX %r3 "$";
    MOV %r4 "global";
    MOV_PROP global %r3 %r4;
    MOV %r4 global;
    MOV %r5 "btoa";
    MOV_PROP %r2 %r4 %r5;
    TYPE_OF %r2;
    MOV %r3 "function";
    NE %r2 %r3;
    JF %r2 _l7_;
    MOV %r4 base64;
    MOV %r5 "btoa";
    MOV_PROP %r3 %r4 %r5;
    MOV %r4 global;
    MOV %r5 "btoa";
    SET_KEY %r4 %r5 %r3;
    JMP _l1_;
LABEL _l7_:
    MOV %r4 global;
    MOV %r5 "atob";
    MOV_PROP %r2 %r4 %r5;
    TYPE_OF %r2;
    MOV %r3 "function";
    NE %r2 %r3;
    JF %r2 _l8_;
    MOV %r4 base64;
    MOV %r5 "atob";
    MOV_PROP %r3 %r4 %r5;
    MOV %r4 global;
    MOV %r5 "atob";
    SET_KEY %r4 %r5 %r3;
    JMP _l1_;
LABEL _l8_:
LABEL _l1_:
}
func @@f2(message) {
    VAR %r0;
    VAR %r1;
    VAR %r2;
    MOV %r0 message;
    MOV_THIS %r1;
    MOV %r2 "message";
    SET_KEY %r1 %r2 %r0;
}
func @@f3(input) {
    VAR str;
    VAR block;
    VAR charCode;
    VAR idx;
    VAR map;
    VAR output;
    VAR %r0;
    VAR %r1;
    VAR %r2;
    VAR %r3;
    VAR %r4;
    VAR %r5;
    VAR %r6;
    VAR %r7;
    MOV %r0 input;
    PUSH %r0;
    CALL_CTX 'String' 1 false;
    MOV str $RET;
    MOV idx 0;
    MOV map @c0;
    MOV output "";
LABEL _l9_:
    MOV %r2 idx;
    MOV %r3 0;
    OR %r2 %r3;
    PUSH %r2;
    MOV %r2 str;
    MOV %r3 "charAt";
    CALL_VAR %r2 %r3 1 false;
    MOV %r1 $RET;
    MOV %r0 %r1;
    JIF %r1 _l13_;
    MOV %r3 "=";
    MOV map %r3;
    MOV %r2 idx;
    MOV %r3 1;
    MOD %r2 %r3;
    LG_OR %r0 %r2;
LABEL _l13_:
    JF %r0 _l10_;
LABEL _l12_:
    MOV %r3 3;
    MOV %r4 4;
    DIV %r3 %r4;
    MOV %r4 idx;
    ADD %r4 %r3;
    MOV idx %r4;
    MOV %r2 %r4;
    PUSH %r2;
    MOV %r2 str;
    MOV %r3 "charCodeAt";
    CALL_VAR %r2 %r3 1 false;
    MOV %r1 $RET;
    MOV charCode %r1;
    MOV %r1 charCode;
    MOV %r2 255;
    GT %r1 %r2;
    JF %r1 _l14_;
    MOV %r3 "'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.";
    PUSH %r3;
    CALL_REG @c1 1 true;
    MOV %r2 $RET;
    THROW %r2;
    JMP _l15_;
LABEL _l14_:
LABEL _l15_:
    MOV %r1 block;
    MOV %r3 8;
    SHL %r1 %r3;
    MOV %r2 charCode;
    OR %r1 %r2;
    MOV block %r1;
LABEL _l11_:
    MOV %r2 63;
    MOV %r3 block;
    MOV %r4 8;
    MOV %r5 idx;
    MOV %r7 1;
    MOD %r5 %r7;
    MOV %r6 8;
    MUL %r5 %r6;
    SUB %r4 %r5;
    SHR %r3 %r4;
    AND %r2 %r3;
    PUSH %r2;
    MOV %r2 map;
    MOV %r3 "charAt";
    CALL_VAR %r2 %r3 1 false;
    MOV %r1 $RET;
    MOV %r2 output;
    ADD %r2 %r1;
    MOV output %r2;
    JMP _l9_;
LABEL _l10_:
    MOV %r0 output;
    MOV $RET %r0;
    RET;
}
func @@f4(input) {
    VAR str;
    VAR bc;
    VAR bs;
    VAR buffer;
    VAR idx;
    VAR output;
    VAR %r0;
    VAR %r1;
    VAR %r2;
    VAR %r3;
    VAR %r4;
    VAR %r5;
    VAR %r6;
    VAR %r7;
    MOV %r0 "";
    PUSH %r0;
    NEW_REG %r0 "[=]+$" "";
    PUSH %r0;
    MOV %r2 input;
    PUSH %r2;
    CALL_CTX 'String' 1 false;
    MOV %r0 $RET;
    MOV %r1 "replace";
    CALL_VAR %r0 %r1 2 false;
    MOV str $RET;
    MOV %r3 str;
    MOV %r4 "length";
    MOV_PROP %r0 %r3 %r4;
    MOV %r2 4;
    MOD %r0 %r2;
    MOV %r1 1;
    EQ %r0 %r1;
    JF %r0 _l16_;
    MOV %r2 "'atob' failed: The string to be decoded is not correctly encoded.";
    PUSH %r2;
    CALL_REG @c1 1 true;
    MOV %r1 $RET;
    THROW %r1;
    JMP _l17_;
LABEL _l16_:
LABEL _l17_:
    MOV bc 0;
    MOV idx 0;
    MOV output "";
LABEL _l18_:
    MOV %r3 idx;
    MOV %r2 %r3;
    ADD %r3 1;
    MOV idx %r3;
    PUSH %r2;
    MOV %r2 str;
    MOV %r3 "charAt";
    CALL_VAR %r2 %r3 1 false;
    MOV %r1 $RET;
    MOV buffer %r1;
    MOV %r0 %r1;
    JF %r0 _l19_;
LABEL _l21_:
    MOV %r2 buffer;
    PUSH %r2;
    MOV %r2 @c0;
    MOV %r3 "indexOf";
    CALL_VAR %r2 %r3 1 false;
    MOV %r1 $RET;
    MOV buffer %r1;
LABEL _l20_:
    MOV %r2 buffer;
    NOT %r2;
    MOV %r1 %r2;
    JF %r2 _l24_;
    MOV %r5 bc;
    MOV %r6 4;
    MOD %r5 %r6;
    JF %r5 _l25_;
    MOV %r4 bs;
    MOV %r7 64;
    MUL %r4 %r7;
    MOV %r6 buffer;
    ADD %r4 %r6;
    JMP _l23_;
LABEL _l25_:
    MOV %r4 buffer;
    MOV bs %r4;
    MOV %r5 bc;
    MOV %r3 %r5;
    ADD %r5 1;
    MOV bc %r5;
    MOV %r4 4;
    MOD %r3 %r4;
    LG_AND %r1 %r3;
LABEL _l24_:
    JF %r1 _l22_;
    MOV %r3 255;
    MOV %r4 bs;
    MOV %r5 2;
    MINUS %r5;
    MOV %r7 bc;
    MUL %r5 %r7;
    MOV %r6 6;
    AND %r5 %r6;
    SHR %r4 %r5;
    AND %r3 %r4;
    PUSH %r3;
    MOV_CTX %r3 "String";
    MOV %r4 "fromCharCode";
    CALL_VAR %r3 %r4 1 false;
    MOV %r2 $RET;
    MOV %r3 output;
    ADD %r3 %r2;
    MOV output %r3;
    JMP _l23_;
LABEL _l22_:
LABEL _l23_:
    JMP _l18_;
LABEL _l19_:
    MOV %r0 output;
    MOV $RET %r0;
    RET;
}
